#!/usr/bin/env python2.6

from __future__ import print_function

import argparse
import logging
import logging.handlers
import os
import psutil
import re
import select
import subprocess
import sys
from time import sleep
import threading


try:
    import rpm
    from rpmUtils.miscutils import getSigInfo
except:
    print("This tool can only run on redhat-derivated hosts")
    sys.exit(-1)


MISSING_RE = re.compile("^missing")
MATCH_RE = re.compile(r'^(?P<size>\.|S)'
                      r'(?P<mode>\.|M)'
                      r'(?P<md5>[\?\.5])'
                      r'(?P<device>\.|D)'
                      r'(?P<link>\.|L)'
                      r'(?P<user>\.|U)'
                      r'(?P<group>\.|G)'
                      r'(?P<mtime>\.|T)'
                      r'(?P<capability>\.|P)'
                      r'  (?P<attribute>[cdglr ]?) '
                      r'(?P<filename>\/.*)$')

TIMEOUT = 3600 * 22
GRACE = 60
SIG_THREASHOLD = 10


def renice(process_id, nice=18, ioclass=psutil.IOPRIO_CLASS_BE, iovalue=6):
    process = psutil.Process(process_id)
    process.set_nice(nice)
    process.set_ionice(ioclass, value=iovalue)


def timeout(process, name):
    if process.poll() is None:
        logging.error('{0} timeout'.format(name))
        process.terminate()
    sleep(GRACE)
    if process.poll() is None:
        logging.error('{0} timeout HARD'.format(name))
        process.terminate()


class Timed(object):
    def __init__(self, process, name):
        self._timer = threading.Timer(1.0 * TIMEOUT, timeout, [process, name])
    def __enter__(self):
        self._timer.start()
    def __exit__(self, ex_type, _ex_value, _tb):
        self._timer.cancel()


def process_stdin(failedchecksumfiles, failedlink, failedcapability, line):
    if MISSING_RE.match(line):
        #skip missing files
        return
    match = MATCH_RE.match(line)
    if match is None:
        if line == '':
            return
        logging.info("Error parsing ''{0}''\n".format(line))
        return
    if match.group('attribute') == 'c':
        #skip config files
        return
    if match.group('md5') != '.':
        failedchecksumfiles.append(match.group('filename').strip())
    if match.group('link') != '.':
        failedlink.append(match.group('filename').strip())
    if match.group('capability') != '.':
        failedcapability.append(match.group('filename').strip())


def get_broken_packages(nice=19, ioclass=psutil.IOPRIO_CLASS_BE, iovalue=7):
    failedchecksumfiles = []
    failedlink = []
    failedcapability = []

    process = subprocess.Popen(["rpm", "-V", "--all"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    renice(process.pid, nice=nice, ioclass=ioclass, iovalue=iovalue)

    with Timed(process, "rpm -V --all"):
        reads = [process.stdout.fileno(), process.stderr.fileno()]
        while True:
            ret = select.select(reads, [], [])
            for fdesc in ret[0]:
                if fdesc == process.stdout.fileno():
                    process_stdin(failedchecksumfiles, failedlink, failedcapability, process.stdout.readline().strip())
                if fdesc == process.stderr.fileno():
                    logging.error(process.stdout.readline().strip())
            if process.poll() != None:
                break
        for line in iter(process.stdout.readline, ''):
            process_stdin(failedchecksumfiles, failedlink, failedcapability, process.stdout.readline().strip())
        for line in iter(process.stderr.readline, ''):
            logging.error(process.stdout.readline().strip())

    return (failedchecksumfiles, failedlink, failedcapability)


def format_package(header):
    return '{0}-{1}-{2}'.format(header[rpm.RPMTAG_NAME], header[rpm.RPMTAG_VERSION], header[rpm.RPMTAG_RELEASE])


def analyse_broken(failedchecksumfiles, failedlink, failedcapability):
    try:
        transactionset = rpm.TransactionSet()
        headers = transactionset.dbMatch()

        for header in headers:
            for filename in header[rpm.RPMTAG_FILENAMES]:
                if filename in failedchecksumfiles:
                    logging.info('File {0} from package {1} has been modified'.format(filename, format_package(header)))
                    failedchecksumfiles.remove(filename)
                if filename in failedlink:
                    logging.info('Link {0} from package {1} has been modified'.format(filename, format_package(header)))
                    failedlink.remove(filename)
                if filename in failedcapability:
                    logging.info('Capacity on file {0} from package {1} has been modified'.format(filename, format_package(header)))
                    failedcapability.remove(filename)

        for filename in failedchecksumfiles:
            logging.info("File " + filename + " from unknown package  has been modified\n")
        for filename in failedlink:
            logging.info("Link " + filename + " from unknown package  has been modified\n")
        for filename in failedcapability:
            logging.info("Capacity on file " + filename + " from unknown package  has been modified\n")
    except rpm.error:
        logging.exception("Error in the RPM code")


def dict_append(dic, key, val):
    try:
        dic[key].append(val)
    except KeyError:
        dic[key] = [val]


def extract_sig(sig):
    raw = sig[1][2]
    if raw.startswith(' Key ID '):
        return raw[7:].strip()
    return raw.strip()


def get_signing_keys():
    sigs = {}
    wrong_sigs = {}
    try:
        transactionset = rpm.TransactionSet()
        headers = transactionset.dbMatch()

        for header in headers:
            if not (header[rpm.RPMTAG_DSAHEADER] or header[rpm.RPMTAG_RSAHEADER]):
                dict_append(wrong_sigs, 'UNSIGNED!', format_package(header))
                continue
            sig = getSigInfo(header)
            if sig[0] == 0:
                dict_append(sigs, extract_sig(sig), format_package(header))
            else:
                dict_append(wrong_sigs, extract_sig(sig), format_package(header))
    except rpm.error:
        logging.exception("Error in the RPM code")
    return (sigs, wrong_sigs)


def process_wrong_sigs(wrong_sigs, ignore_unsigned):
    try:
        unsigneds = wrong_sigs['UNSIGNED!']
        del wrong_sigs['UNSIGNED!']
    except KeyError:
        unsigneds = []
    if not ignore_unsigned:
        for package in unsigneds:
            logging.info('Unsigned package {0}'.format(package))
    for key in wrong_sigs:
        for package in wrong_sigs[key]:
            logging.info('Wrong signature with key {0} on package {1}'.format(key, package))


def process_sigs(sigs, known_keys=None):
    for key in known_keys:
        try:
            del sigs[key]
        except KeyError:
            pass
    for key in sigs:
        if known_keys is None:
            if len(sigs[key]) < SIG_THREASHOLD:
                logging.info('Suspicious key {0}, only signing {1} packages:'.format(key, len(sigs[key])))
                for package in sigs[key]:
                    logging.info('Suspicious key {0} used on package {1}'.format(key, package))
        else:
            for package in sigs[key]:
                logging.info('Unkown key {0} used on package {1}'.format(key, package))


def get_conf():
    parser = argparse.ArgumentParser(description='Verify installed RPMS')
    parser.add_argument('--nice', default=19, type=int, help='Set the scheduling priority (default: %(default)s)')
    parser.add_argument('--ioclass', default=psutil.IOPRIO_CLASS_BE, type=int, help='Set the io scheduling class (default: %(default)s)')
    parser.add_argument('--ionice', default=7, type=int, help='Set the io scheduling priority (default: %(default)s)')
    parser.add_argument('--priority-diff', default=1, type=int, help='Priority difference between parsing and hashing')
    parser.add_argument('-f', action='store_true', dest='here', help='Print logs on the screen instead of using syslog')
    parser.add_argument('--disable-hash', action='store_true', help='Disable rpm verification (hashing files)')
    parser.add_argument('--disable-signatures', action='store_true', help='Disable signature verification')
    parser.add_argument('--trusted-keys', help='Coma-separated list of trusted signing keys')
    parser.add_argument('--ignore-unsigned', action='store_true', help='Ignore unsigned rpms (dangerous!)')
    return parser.parse_args()

def main(conf):
    renice(os.getpid(), nice=(conf.nice - conf.priority_diff), ioclass=conf.ioclass, iovalue=(conf.ionice - conf.priority_diff))
    if not conf.disable_hash:
        (failedchecksumfiles, failedlink, failedcapability) = get_broken_packages(nice=conf.nice, ioclass=conf.ioclass, iovalue=conf.ionice)
        analyse_broken(failedchecksumfiles, failedlink, failedcapability)
    if not conf.disable_signatures: 
        (sigs, wrong_sigs) = get_signing_keys()
        process_wrong_sigs(wrong_sigs, conf.ignore_unsigned)
        if conf.trusted_keys:
            process_sigs(sigs, known_keys=conf.trusted_keys.split(','))
        else:
            process_sigs(sigs)


if __name__ == '__main__':
    conf = get_conf()
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.DEBUG)
    if conf.here:
        handler = logging.StreamHandler()
    else:
        handler = logging.handlers.SysLogHandler(address='/dev/log')
    formatter = logging.Formatter('cern-rpmverify: %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logging.info('started')
    try:
        main(conf)
        logging.info('finished')
    except KeyboardInterrupt:
        logging.error('killed')
    except Exception:
        logging.exception('failed')
        raise
