#!/usr/bin/env python2.6

import argparse
import functools
import logging
import logging.handlers
import os
import psutil
import re
import select
import signal
import subprocess
import sys
import syslog
from time import sleep
import threading


try:
    import rpm
    from rpmUtils.miscutils import getSigInfo
except:
    print("This tool can only run on redhat-derivated hosts")
    sys.exit(-1)


MISSING_RE = re.compile("^missing")
MATCH_RE   = re.compile(r'^(?P<size>\.|S)'
                         '(?P<mode>\.|M)'
                         '(?P<md5>[\?\.5])'
                         '(?P<device>\.|D)'
                         '(?P<link>\.|L)'
                         '(?P<user>\.|U)'
                         '(?P<group>\.|G)'
                         '(?P<mtime>\.|T)'
                         '(?P<capability>\.|P)'
                         '  (?P<attribute>[cdglr ]?) '
                         '(?P<filename>\/.*)$')

TIMEOUT = 3600 * 22
GRACE   = 60
SIG_THREASHOLD = 10


def logged(fn):
    """Decorator for logging"""
    @functools.wraps(fn)
    def wrapped(syslog, *args, **kwargs):
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.DEBUG)
        if syslog:
            handler = logging.handlers.SysLogHandler(address='/dev/log')
        else:
            handler = logging.StreamHandler()
        formatter = logging.Formatter('cern-rpmverify: %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.info('started')
        try:
            fn(*args, logger=logger, **kwargs)
            logger.info('finished')
        except KeyboardInterrupt:
            logger.error('killed')
        except Exception as e:
            logger.error('failed: {0}'.format(str(e)))
            raise
    return wrapped


def renice(process_id, nice=18, ioclass=psutil.IOPRIO_CLASS_BE, iovalue=6):
    process = psutil.Process(process_id)
    process.set_nice(nice)
    process.set_ionice(ioclass, value=iovalue)


def timeout(logger, process, name):
    if process.poll() is None:
        logger.error('{0} timeout'.format(name))
        process.terminate()
    sleep(GRACE)
    if process.poll() is None:
        logger.error('{0} timeout HARD'.format(name))
        process.terminate()


class Timed(object):
    def __init__(self, logger, process, name):
        self._timer = threading.Timer(1.0 * TIMEOUT, timeout, [logger, process, name])
    def __enter__(self):
        self._timer.start()
    def __exit__(self, ex_type, _ex_value, _tb):
        self._timer.cancel()


def process_stdin(logger, failedChecksumFiles, failedLink, failedCapability, line):
    if MISSING_RE.match(line):
        #skip missing files
        return
    match = MATCH_RE.match(line)
    if match is None:
        if line == '':
            return
        logger.info("Error parsing ''{0}''\n".format(line))
        return
    if match.group('attribute') == 'c':
        #skip config files
        return
    if match.group('md5') != '.':
        failedChecksumFiles.append(match.group('filename').strip())
    if match.group('link') != '.':
        failedLink.append(match.group('filename').strip())
    if match.group('capability') != '.':
        failedCapability.append(match.group('filename').strip())


def get_broken_packages(logger, nice=19, ioclass=psutil.IOPRIO_CLASS_BE, iovalue=7):
    failedChecksumFiles = []
    failedLink = []
    failedCapability = []

    process = subprocess.Popen(["rpm", "-V", "--all"], stdout = subprocess.PIPE, stderr = subprocess.PIPE)
    renice(process.pid, nice=nice, ioclass=ioclass, iovalue=iovalue)

    with Timed(logger, process, "rpm -V --all"):
        reads = [process.stdout.fileno(), process.stderr.fileno()]
        while True:
            ret = select.select(reads, [], [])
            for fd in ret[0]:
                if fd == process.stdout.fileno():
                    process_stdin(logger, failedChecksumFiles, failedLink, failedCapability, process.stdout.readline().strip())
                if fd == process.stderr.fileno():
                    logger.error(process.stdout.readline().strip())
            if process.poll() != None:
                break
        for line in iter(process.stdout.readline, ''):
            process_stdin(logger, failedChecksumFiles, failedLink, failedCapability, process.stdout.readline().strip())
        for line in iter(process.stderr.readline, ''):
            logger.error(process.stdout.readline().strip())

    return (failedChecksumFiles, failedLink, failedCapability)


def format_package(header):
    return '{0}-{1}-{2}'.format(header[rpm.RPMTAG_NAME], header[rpm.RPMTAG_VERSION], header[rpm.RPMTAG_RELEASE])


def analyse_broken(logger, failedChecksumFiles, failedLink, failedCapability):
    try:
        transactionSet = rpm.TransactionSet()
        headers = transactionSet.dbMatch()

        for header in headers:
            for filename in header[rpm.RPMTAG_FILENAMES]:
                if filename in failedChecksumFiles:
                    logger.info('File {0} from package {1} has been modified'.format(filename, format_package(header)))
                    failedChecksumFiles.remove(filename)
                if filename in failedLink:
                    logger.info('Link {0} from package {1} has been modified'.format(filename, format_package(header)))
                    failedLink.remove(filename)
                if filename in failedCapability:
                    logger.info('Capacity on file {0} from package {1} has been modified'.format(filename, format_package(header)))
                    failedCapability.remove(filename)

        for filename in failedChecksumFiles:
            logger.info("File " + filename + " from unknown package  has been modified\n")
        for filename in failedLink:
            logger.info("Link " + filename + " from unknown package  has been modified\n")
        for filename in failedCapability:
            logger.info("Capacity on file " + filename + " from unknown package  has been modified\n")
    except rpm._rpm.error as e:
        logger.error("Error in the RPM code: {0}".format(str(e)))


def dict_append(dic, key, val):
    try:
        dic[key].append(val)
    except KeyError:
        dic[key] = [val]


def extract_sig(sig):
    raw = sig[1][2]
    if raw.startswith(' Key ID '):
        return raw[7:].strip()
    return raw.strip()


def get_signing_keys(logger):
    sigs = {}
    wrong_sigs = {}
    try:
        transactionSet = rpm.TransactionSet()
        headers = transactionSet.dbMatch()

        for header in headers:
            if not (header[rpm.RPMTAG_DSAHEADER] or header[rpm.RPMTAG_RSAHEADER]):
                dict_append(wrong_sigs, 'UNSIGNED!', format_package(header))
                continue
            sig = getSigInfo(header)
            if sig[0] == 0:
                dict_append(sigs, extract_sig(sig),  format_package(header))
            else:
                dict_append(wrong_sigs, extract_sig(sig),  format_package(header))
    except rpm._rpm.error as e:
        logger.error('Error in the RPM code: {0}'.format(str(e)))
    return (sigs, wrong_sigs)


def process_wrong_sigs(logger, wrong_sigs, ignore_unsigned):
    try:
        unsigneds = wrong_sigs['UNSIGNED!']
        del wrong_sigs['UNSIGNED!']
    except KeyError:
        unsigneds = []
    if not ignore_unsigned:
        for package in unsigneds:
            logger.info('Unsigned package {0}'.format(package))
    for key in wrong_sigs:
        for package in wrong_sigs[key]:
            logger.info('Wrong signature with key {0} on package {1}'.format(key, package))


def process_sigs(logger, sigs, known_keys=[]):
    for key in known_keys:
        try:
            del sigs[key]
        except KeyError:
            pass
    for key in sigs:
        if (known_keys == []):
            if len(sigs[key]) < SIG_THREASHOLD:
                logger.info('Suspicious key {0}, only signing {1} packages:'.format(key, len(sigs[key])))
                for package in sigs[key]:
                    logger.info('Suspicious key {0} used on package {1}'.format(key, package))
        else:
            for package in sigs[key]:
                logger.info('Unkown key {0} used on package {1}'.format(key, package))


def get_conf():
    parser = argparse.ArgumentParser(description='Verify installed RPMS')
    parser.add_argument('--nice', default=19, type=int, help='Set the scheduling priority (default: %(default)s)')
    parser.add_argument('--ioclass', default=psutil.IOPRIO_CLASS_BE, type=int, help='Set the io scheduling class (default: %(default)s)')
    parser.add_argument('--ionice', default=7, type=int, help='Set the io scheduling priority (default: %(default)s)')
    parser.add_argument('--priority-diff', default=1, type=int, help='Priority difference between parsing and hashing')
    parser.add_argument('-f', action='store_true', dest='here', help='Print logs on the screen instead of using syslog')
    parser.add_argument('--disable-hash', action='store_true', help='Disable rpm verification (hashing files)')
    parser.add_argument('--disable-signatures', action='store_true', help='Disable signature verification')
    parser.add_argument('--trusted-keys', help='Coma-separated list of trusted signing keys')
    parser.add_argument('--ignore-unsigned', action='store_true', help='Ignore unsigned rpms (dangerous!)')
    return parser.parse_args()

@logged
def main(logger, conf):
    renice(os.getpid(), nice=(conf.nice - conf.priority_diff), ioclass=conf.ioclass, iovalue=(conf.ionice - conf.priority_diff))
    if not conf.disable_hash:
        (failedChecksumFiles, failedLink, failedCapability) = get_broken_packages(logger, nice=conf.nice, ioclass=conf.ioclass, iovalue=conf.ionice)
        analyse_broken(logger, failedChecksumFiles, failedLink, failedCapability)
    if not conf.disable_signatures: 
        (sigs, wrong_sigs) = get_signing_keys(logger)
        process_wrong_sigs(logger, wrong_sigs, conf.ignore_unsigned)
        if conf.trusted_keys:
            process_sigs(logger, sigs, known_keys=conf.trusted_keys.split(','))
        else:
            process_sigs(logger, sigs)


if __name__ == '__main__':
    conf = get_conf()
    main(not conf.here, conf=conf)
