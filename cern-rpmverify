#!/usr/bin/env python2.6

import functools
import logging
import logging.handlers
import os
import psutil
import re
import select
import signal
import subprocess
import sys
import syslog
from time import sleep
import threading


try:
    import rpm
except:
    print("This tool can only run on redhat-derivated hosts")
    sys.exit(-1)


MISSING_RE = re.compile("^missing")
MATCH_RE   = re.compile(r'^(?P<size>\.|S)'
                         '(?P<mode>\.|M)'
                         '(?P<md5>[\?\.5])'
                         '(?P<device>\.|D)'
                         '(?P<link>\.|L)'
                         '(?P<user>\.|U)'
                         '(?P<group>\.|G)'
                         '(?P<mtime>\.|T)'
                         '(?P<capability>\.|P)'
                         '  (?P<attribute>[cdglr ]?) '
                         '(?P<filename>\/.*)$')

TIMEOUT = 3600 * 22
GRACE   = 60


def logged(fn):
    """Decorator for logging"""
    @functools.wraps(fn)
    def wrapped(*args, **kwargs):
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.DEBUG)
        handler = logging.handlers.SysLogHandler(address='/dev/log')
        formatter = logging.Formatter('cern-rpmverify: %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.info('started')
        try:
            fn(*args, logger=logger, **kwargs)
            logger.info('finished')
        except KeyboardInterrupt:
            logger.error('killed')
        except Exception as e:
            logger.error('failed: {0}'.format(str(e)))
    return wrapped


def renice(process_id, nice=18, ioclass=psutil.IOPRIO_CLASS_BE, iovalue=6):
    process = psutil.Process(process_id)
    process.set_nice(nice)
    process.set_ionice(ioclass, value=iovalue)


def timeout(logger, process, name):
    if process.poll() is None:
        logger.error('{0} timeout'.format(name))
        process.terminate()
    sleep(GRACE)
    if process.poll() is None:
        logger.error('{0} timeout HARD'.format(name))
        process.terminate()


class Timed(object):
    def __init__(self, logger, process, name):
        self._timer = threading.Timer(1.0 * TIMEOUT, timeout, [logger, process, name])
    def __enter__(self):
        self._timer.start()
    def __exit__(self, ex_type, _ex_value, _tb):
        self._timer.cancel()


def process_stdin(logger, failedChecksumFiles, failedLink, failedCapability, line):
    if MISSING_RE.match(line):
        #skip missing files
        return
    match = MATCH_RE.match(line)
    if match is None:
        if line == '':
            return
        logger.info("Error parsing ''{0}''\n".format(line))
        return
    if match.group('attribute') == 'c':
        #skip config files
        return
    if match.group('md5') != '.':
        failedChecksumFiles.append(match.group('filename').strip())
    if match.group('link') != '.':
        failedLink.append(match.group('filename').strip())
    if match.group('capability') != '.':
        failedCapability.append(match.group('filename').strip())


def get_broken_packages(logger):
    failedChecksumFiles = []
    failedLink = []
    failedCapability = []

    process = subprocess.Popen(["rpm", "-V", "--all"], stdout = subprocess.PIPE, stderr = subprocess.PIPE)
    renice(process.pid, nice=19, iovalue=7)

    with Timed(logger, process, "rpm -V --all"):
        reads = [process.stdout.fileno(), process.stderr.fileno()]
        while True:
            ret = select.select(reads, [], [])
            for fd in ret[0]:
                if fd == process.stdout.fileno():
                    process_stdin(logger, failedChecksumFiles, failedLink, failedCapability, process.stdout.readline().strip())
                if fd == process.stderr.fileno():
                    logger.error(process.stdout.readline().strip())
            if process.poll() != None:
                break
        for line in iter(process.stdout.readline, ''):
            process_stdin(logger, failedChecksumFiles, failedLink, failedCapability, process.stdout.readline().strip())
        for line in iter(process.stderr.readline, ''):
            logger.error(process.stdout.readline().strip())

    return (failedChecksumFiles, failedLink, failedCapability)


def format_package(header):
    return '{0}-{1}-{2}'.format(header[rpm.RPMTAG_NAME], header[rpm.RPMTAG_VERSION], header[rpm.RPMTAG_RELEASE])


def analyse_broken(logger, failedChecksumFiles, failedLink, failedCapability):
    try:
        transactionSet = rpm.TransactionSet()
        headers = transactionSet.dbMatch()

        for header in headers:
            for filename in header[rpm.RPMTAG_FILENAMES]:
                if filename in failedChecksumFiles:
                    logger.info('File {0} from package {1} has been modified'.format(filename, format_package(header)))
                    failedChecksumFiles.remove(filename)
                if filename in failedLink:
                    logger.info('Link {0} from package {1} has been modified'.format(filename, format_package(header)))
                    failedLink.remove(filename)
                if filename in failedCapability:
                    logger.info('Capacity on file {0} from package {1} has been modified'.format(filename, format_package(header)))
                    failedCapability.remove(filename)

        for filename in failedChecksumFiles:
            logger.info("File " + filename + " from unknown package  has been modified\n")
        for filename in failedLink:
            logger.info("Link " + filename + " from unknown package  has been modified\n")
        for filename in failedCapability:
            logger.info("Capacity on file " + filename + " from unknown package  has been modified\n")
    except rpm._rpm.error as e:
        logger.error("Error in the RPM code: {0}".format(str(e)))


@logged
def main(logger):
    renice(os.getpid())
    (failedChecksumFiles, failedLink, failedCapability) = get_broken_packages(logger)
    analyse_broken(logger, failedChecksumFiles, failedLink, failedCapability)


if __name__ == '__main__':
    main()
